package tools

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	"routing-algorithms/network"
	"routing-algorithms/random"
)

// read network from alt file generated by gt-itm, generate latency and jitter randomly
func ReadAltNet(filePath string) network.Network {
	file, err := os.Open(filePath)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	var fileContent []string
	for scanner.Scan() {
		line := scanner.Text()
		fileContent = append(fileContent, line)
	}

	splitLine2 := strings.Split(fileContent[1], " ")

	numNodes, _ := strconv.Atoi(splitLine2[0])
	numDirectedLinks, _ := strconv.Atoi(splitLine2[1])
	numUndirectedLinks := numDirectedLinks / 2

	var net network.Network
	net.Nodes = make([]network.Node, numNodes)
	net.Links = make([][]int, numNodes)
	net.Jitters = make([][]int, numNodes)
	for i := 0; i < numNodes; i++ {
		net.Links[i] = make([]int, numNodes)
		net.Jitters[i] = make([]int, numNodes)
		for j := 0; j < numNodes; j++ {
			net.Links[i][j] = -1   // init latency to -1
			net.Jitters[i][j] = -1 // init jitters to -1
		}
	}

	// read edges
	if !strings.HasPrefix(fileContent[3+numNodes+2], "EDGES") {
		panic(fmt.Errorf("%d line does not start with \"EDGES\"", 3+numNodes+2))
	}

	for i := 1; i <= numUndirectedLinks; i++ {
		edge := strings.Split(fileContent[3+numNodes+2+i], " ")
		node1, _ := strconv.Atoi(edge[0])
		node2, _ := strconv.Atoi(edge[1])
		// latency of every link is a random number following Poisson distribution, lambda=7, between [3,15]
		net.Links[node1][node2] = random.PoissonRandom(3, 15, 7)
		net.Links[node2][node1] = net.Links[node1][node2]
		// jitter of every link is a random number following Normal distribution, miu=4, sigma=6, between [1,10]
		net.Jitters[node1][node2] = int(random.NormalRandomBM(1, 10, 4, 6))
		net.Jitters[node2][node1] = net.Jitters[node1][node2]
	}

	return net
}

// write content to json file
func WriteJson(v interface{}, outPath string) {
	data, err := json.Marshal(v)
	if err != nil {
		panic(err)
	}
	err = ioutil.WriteFile(outPath, data, 0777)
	if err != nil {
		panic(err)
	}
}

// read network from json file
func ReadJsonNet(filePath string) network.Network {
	netData, err := ioutil.ReadFile(filePath)
	if err != nil {
		panic(err)
	}
	var net network.Network
	err = json.Unmarshal(netData, &net)
	if err != nil {
		panic(err)
	}
	return net
}

// use alt files in "gtitmnetworks" to generate json files in "jsonnetworks"
func GenerateAllNets(num int) {
	var netName string
	for i := 1; i <= num; i++ {
		if i < 10 {
			netName = fmt.Sprintf("net0%d", i)
		} else {
			netName = fmt.Sprintf("net%d", i)
		}
		net := ReadAltNet("./experiments/r2t-dsdn-config/gtitmnetworks/" + netName + ".alt")
		WriteJson(net, "./experiments/r2t-dsdn-config/jsonnetworks/"+netName+".json")
	}
}

// generate num scenarios for net
func GenerateFlowsForNet(net network.Network, num int) [][]network.Flow {
	// generate num scenarios
	var flows [][]network.Flow = make([][]network.Flow, num)
	for i := 0; i < num; i++ {
		// in every scenario there are [5,20] flows
		numFlows := random.RandomInt(5, 20)
		// in every scenario there are [0,numFlows] RT-flows
		numRTFlows := random.RandomInt(0, numFlows)

		flows[i] = make([]network.Flow, numFlows)
		for j := 0; j < numFlows; j++ {
			// generate source and destination
			flows[i][j].Source = random.RandomInt(0, len(net.Nodes)-1)
			flows[i][j].Destination = random.RandomInt(0, len(net.Nodes)-1)
			for flows[i][j].Source == flows[i][j].Destination {
				flows[i][j].Destination = random.RandomInt(0, len(net.Nodes)-1)
			}

			// generate desirableJitter
			flows[i][j].DesirableJitter = int(random.NormalRandomBM(3*10, 15*10, 8*10, 7*10))

			// generate data
			flows[i][j].Data = int(random.NormalRandomBM(10, 30, 20, 10))

			// generate deadline
			flows[i][j].Deadline = -1 // in non-RT flows, deadline is -1
			if j < numRTFlows {
				// transmission time is the sum of latency of links, if transmission time <= deadline, it can hit deadline
				flows[i][j].Deadline = int(random.NormalRandomBM(50, 150, 80, 85))
			}
		}
	}
	return flows
}

// read flows from json file
func ReadJsonFlows(filePath string) [][]network.Flow {
	flowData, err := ioutil.ReadFile(filePath)
	if err != nil {
		panic(err)
	}
	var flows [][]network.Flow
	err = json.Unmarshal(flowData, &flows)
	if err != nil {
		panic(err)
	}
	return flows
}

// read json files of networks in "jsonnetworks" to generate json files of flows in "jsonnetworks", generate numScenario scenarios for every net
func GenerateAllFlows(numNet, numScenario int) {
	var netName string
	for i := 1; i <= numNet; i++ {
		if i < 10 {
			netName = fmt.Sprintf("net0%d", i)
		} else {
			netName = fmt.Sprintf("net%d", i)
		}
		net := ReadJsonNet("./experiments/r2t-dsdn-config/jsonnetworks/" + netName + ".json")
		flows := GenerateFlowsForNet(net, numScenario)
		WriteJson(flows, "./experiments/r2t-dsdn-config/jsonnetworks/"+netName+"_flows.json")
	}
}
